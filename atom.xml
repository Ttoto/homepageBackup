<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Ttoto的后花园]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-10-20T21:38:25.312Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[SY.Chen]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[sfm项目杂谈2-坐标变换]]></title>
    <link href="http://yoursite.com/2016/10/20/reconstruction2/"/>
    <id>http://yoursite.com/2016/10/20/reconstruction2/</id>
    <published>2016-10-20T21:06:27.000Z</published>
    <updated>2016-10-20T21:38:25.312Z</updated>
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<h3 id="问题描述">问题描述</h3><p>之前做的学生项目到了evaluation的阶段。需要把sfm的结果和真实数据进行比较。需要用数据集里面的相机准确pose来进行一次重建。<br>数据集中的坐标系基于World-Coordinate。在sfm的方法中我们的Initial-Coordinate是按照第一张图片来建立的。第一张图片是在w系原点拍摄的所以两个坐标系不存在Transmission，只有Rotation。<br>两个坐标系的对应关系是： W_x 对应 I_z; W_y 对应 -I_x; W_z 对应 -I_y。<br>具体的问题：通过W系下面的Quaternion形式的Pose，写出基于I坐标系下的相机Position Matrix。</p>
<h3 id="方法">方法</h3><p>进行旋转变换大概可以用以下三种形式做。<br>1四元数下进行旋转<br>2旋转矩阵进行旋转<br>3欧拉角旋转<br>我们的情况比较特殊三个坐标轴只是方向不同，我选择用欧拉角进行坐标变换，之后再拼凑数Position Matrix.</p>
<h3 id="代码与解释">代码与解释</h3><p><pre><code><br>    cv::Matx44d Q_1,Q_2,R_tmp;<br>    double px,py,pz,qx,qy,qz,qw;<br>    px=msg-&gt;pose.position.x;<br>    py=msg-&gt;pose.position.y;<br>    pz=msg-&gt;pose.position.z;<br>    qx=msg-&gt;pose.orientation.x;<br>    qy=msg-&gt;pose.orientation.y;<br>    qz=msg-&gt;pose.orientation.z;<br>    qw=msg-&gt;pose.orientation.w;<br>    Q_1 = cv::Matx44d( qw,   qz,  -qy,   qx,<br>                       -qz,   qw,   qx,   qy,<br>                       qy,  -qx,   qw,   qz,<br>                       -qx,  -qy,  -qz,   qw);<br>    Q_2 = cv::Matx44d( qw,   qz,  -qy,  -qx,<br>                       -qz,   qw,   qx,  -qy,<br>                       qy,  -qx,   qw,  -qz,<br>                       qx,   qy,   qz,   qw);<br>    R_tmp = Q_1_Q_2;<br>    double ysqr = qy _ qy;<br>    double t0 = -2.0f _ (ysqr + qz _ qz) + 1.0f;<br>    double t1 = +2.0f _ (qx _ qy + qw _ qz);<br>    double t2 = -2.0f _ (qx _ qz - qw _ qy);<br>    double t3 = +2.0f _ (qy _ qz + qw _ qx);<br>    double t4 = -2.0f _ (qx * qx + ysqr) + 1.0f;<br>    t2 = t2 &gt; 1.0f ? 1.0f : t2;<br>    t2 = t2 &lt; -1.0f ? -1.0f : t2;<br>    double world_p = std::asin(t2);<br>    double world_r = std::atan2(t3, t4);<br>    double world_y = std::atan2(t1, t0);<br></code></pre><br>    从Quaternion形式获取W系下的欧拉角。</p>
<p><pre><code><br>    double cam_p = -world_y-(3.14159/2);<br>    double cam_r = -world_p;<br>    double cam_y = world_r;<br></code></pre><br>    欧拉角进行坐标系的变换。</p>
<p><pre><code><br>    cv::Matx33d R_x,R_y,R_z,R_t;<br>    R_x &lt;&lt; 1,0,0,<br>        0,cos(cam_r),-sin(cam_r),<br>        0,sin(cam_r),cos(cam_r);<br>    R_y &lt;&lt; cos(cam_p),0,sin(cam_p),<br>        0,1,0,<br>        -sin(cam_p),0,cos(cam_p);<br>    R_z &lt;&lt; cos(cam_y),-sin(cam_y),0,<br>        sin(cam_y),cos(cam_y),0,<br>        0,0,1;<br>    R_t = R_z_R_y_R_x;<br>    R_t = R_t.inv();<br>    cv::Matx34d Pmat;<br>    cv::Matx31d c,t;<br>    c &lt;&lt; -1.0_py,-1.0_pz,px;<br>    t = -R_t*c;<br>    Pmat &lt;&lt; R_t(0,0),R_t(0,1),R_t(0,2),t(0),<br>        R_t(1,0),R_t(1,1),R_t(1,2),t(1),<br>        R_t(2,0),R_t(2,1),R_t(2,2),t(2);<br>    string pmatfilename = PMAT_PATH + int2filename(count/5) + “.png.pmat”;<br>    cout &lt;&lt; pmatfilename &lt;&lt; endl;<br>    stort_pmat(pmatfilename,Pmat);</code></pre></p>
<p><br>    用欧拉角和位移写出Positon Matrix。</p>
<h3 id="最后的话">最后的话</h3><p>最近开始真正调整自己的状态，希望之后的更新能够更加及时。</p>
]]></content>
    <summary type="html">
    <![CDATA[<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    ]]>
    </summary>
    
      <category term="CV" scheme="http://yoursite.com/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sfm项目杂谈]]></title>
    <link href="http://yoursite.com/2016/09/28/reconstruction/"/>
    <id>http://yoursite.com/2016/09/28/reconstruction/</id>
    <published>2016-09-28T11:31:32.000Z</published>
    <updated>2016-09-29T10:50:22.043Z</updated>
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<h3 id="缘起">缘起</h3><p>读书的时候可以没有负担的尝试一下不同的研究方向，加上自己对cv比较感兴趣，选了一个sfm的题目作为studentenarbeit。拖拖沓沓做到现在，也算有了结果。<br><img src="http://7xnxd9.com1.z0.glb.clouddn.com/reconstruction_1.png?imageView2/2/w/1152/h/830" class="img-center"></p>
<h3 id="sfm的流程">sfm的流程</h3><p>sfm的pipeline大概可以分为两个步骤。<br>1，最初的2张图像的重建。主要是<br>2，每添加一张新的图片，通过和之前的图片匹配，找到一系列已经重建出的三维点和对应新图片中的位置，最后算出新图片的P_matrix。使用的是OpenCV里面的方法 cv::solvePnPRansac</p>
<h3 id="SfM-Toy-Library_中相机的位置">SfM-Toy-Library 中相机的位置</h3><p>在完成每一张图片的重建后我们得到了P-matrix</p>
<pre><code>
    Pmats[rec_index] = cv::Matx34d  (R(0,0),R(0,1),R(0,2),t(0),
                                     R(1,0),R(1,1),R(1,2),t(1),
                                     R(2,0),R(2,1),R(2,2),t(2));
</code></pre>
我们用以下代码从P-matrix中获取各个相机的位置
<pre><code>
    Eigen::Matrix<double, 4="" 3,=""> P_ = Eigen::Map<eigen::matrix<double, 3,="" 4,="" eigen::rowmajor=""> >(Pmats[rec_index].val);
    Eigen::Matrix3d R_ = P_.block(0, 0, 3, 3);
    Eigen::Vector3d t_ = P_.block(0, 3, 3, 1);
    Eigen::Vector3d c = -R_.transpose() * t_;
</eigen::matrix<double,></double,></code></pre>

<p>这里的c就是相机的坐标，在SfM-Toy-Library这部分的代码是放在viewer里面做的，但是在实际评估中我们经常要使用到相机的位置。</p>
<h3 id="显示部分的改进">显示部分的改进</h3><p>的SfM-Toy-Library 用了libQGLViewer来显示结果，最后用三个坐标轴来表示相机的方向。为了更好的展示结果我后面改为pyramid的表示方法，同时修正了Rotation相反的问题。效果如下图：<br><img src="http://7xnxd9.com1.z0.glb.clouddn.com/reconstruction_2.png?imageView2/2/w/614/h/496/format/jpg" class="img-center"><br>修正Rotation反向问题: R.inverse()</p>
<pre><code>
    //compute transformation to place cameras in world
    m_cameras_transforms.resize(m_cameras.size());
    Eigen::Vector3d c_sum(0, 0, 0);
    for (unsigned int i = 0; i < m_cameras.size(); ++i) {
        Eigen::Matrix<double, 4="" 3,=""> P = Eigen::Map<eigen::matrix<double, 3,="" 4,="" eigen::rowmajor=""> >(m_cameras[i].val);
        Eigen::Matrix3d R = P.block(0, 0, 3, 3);
        Eigen::Vector3d t = P.block(0, 3, 3, 1);
        Eigen::Vector3d c = -R.transpose() * t;
        //cout << t << endl << endl;
        //cout << R << endl << endl;
        //cout << c << endl << endl;
        c_sum += c;
        m_cameras_transforms[i] = Eigen::Translation<double, 3="">(c)
                                * Eigen::Quaterniond(R.inverse())
                                * Eigen::UniformScaling<double>(m_scale_cameras_down);
    }
</double></double,></eigen::matrix<double,></double,></code></pre>
使用pyramid的表示方法： 
<pre><code>

    #define CAM_SIZE (20)
    #define CAM_W (CAM_SIZE)
    #define CAM_H (CAM_SIZE*0.68)
    #define CAM_DEPTH (CAM_SIZE)

    glEnable(GL_RESCALE_NORMAL);
    //glScaled(scale_cameras_down,scale_cameras_down,scale_cameras_down);
    //glEnable(GL_LIGHTING);
    for (unsigned int i = 0; i < m_cameras_transforms.size(); ++i) {

        glPushMatrix();
        glMultMatrixd(m_cameras_transforms[i].data());

        glLineWidth(1.0);
        glColor4f(0.8, 0.8, 0.8, 0.5);
        glBegin(GL_LINES);
        glVertex3f(-CAM_W, CAM_H, CAM_DEPTH);
        glVertex3f(CAM_W, CAM_H, CAM_DEPTH);
        glEnd();

        glBegin(GL_LINES);
        glVertex3f(CAM_W, CAM_H, CAM_DEPTH);
        glVertex3f(CAM_W, -CAM_H, CAM_DEPTH);
        glEnd();

        glBegin(GL_LINES);
        glVertex3f(CAM_W, -CAM_H, CAM_DEPTH);
        glVertex3f(-CAM_W, -CAM_H, CAM_DEPTH);
        glEnd();

        glBegin(GL_LINES);
        glVertex3f(-CAM_W, -CAM_H, CAM_DEPTH);
        glVertex3f(-CAM_W, CAM_H, CAM_DEPTH);
        glEnd();

        glColor4f(0.6, 0.6, 0, 0.5);
        glBegin(GL_LINES);
        glVertex3f(0, 0, 0);
        glVertex3f(-CAM_W, CAM_H, CAM_DEPTH);
        glEnd();
        glBegin(GL_LINES);
        glVertex3f(0, 0, 0);
        glVertex3f(-CAM_W, -CAM_H, CAM_DEPTH);
        glEnd();
        glBegin(GL_LINES);
        glVertex3f(0, 0, 0);
        glVertex3f(CAM_W, -CAM_H, CAM_DEPTH);
        glEnd();
        glBegin(GL_LINES);
        glVertex3f(0, 0, 0);
        glVertex3f(CAM_W, CAM_H, CAM_DEPTH);
        glEnd();

    //glColor4f(1, 1, 1, 1);
    //QGLViewer::drawArrow(qglviewer::Vec(0, 0, 0), qglviewer::Vec(0, 0, CAM_DEPTH),1);
    //glColor4f(0, 1, 0, 1);
    //QGLViewer::drawArrow(qglviewer::Vec(0, 0, 0), qglviewer::Vec(0, 50, 0),5);
    //glColor4f(0, 0, 1, 1);
    //QGLViewer::drawArrow(qglviewer::Vec(0, 0, 0), qglviewer::Vec(0, 0, 50),5);

        glPopMatrix();
    }
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    ]]>
    </summary>
    
      <category term="CV" scheme="http://yoursite.com/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从Z域看PID控制器]]></title>
    <link href="http://yoursite.com/2016/08/19/pid/"/>
    <id>http://yoursite.com/2016/08/19/pid/</id>
    <published>2016-08-19T19:30:32.000Z</published>
    <updated>2016-08-20T20:38:43.042Z</updated>
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p>&emsp;&emsp;</p>
<h3 id="来龙去脉">来龙去脉</h3><p>最近在复习控制的一个考试，翻到了一个关于PID的案例，又有了新的发现。不敢独享。问题的提出是因为传感器的噪声会在微分项放大，在设计控制器的时候往往在微分环节加一个一阶系统来抑制噪声。设计这样一个系统在时域上理解比较晦涩，但是通过Z变换后形式变得异常简单。</p>
<h3 id="庖丁解牛">庖丁解牛</h3><p>图片是是pid控制器的框图。<br><img src="http://i2.buimg.com/4851/ea0ec90f6b1a3465.jpg" alt=""></p>
<p>我们在微分项加入一个用于抑制高频噪声的一阶系统<br><img src="http://i2.buimg.com/4851/b66c2d126b3d5b48.jpg" alt=""><br>新系统的传递函数<br>$$G_{PID}(s)=K_p(1+\frac{1}{T_Ns}+\frac{T_vs}{1+sT_{Tp}})$$<br>我们要把它用Z变换来表示，其实就是把传递函数用s来表示。我们引入一个积分的例子来找出替换的形式。积分在S域表现为1/s。时域上的表示为<br>$$x(t)=\int_{0}^{t}u(\tau )d\tau $$<br>在数字系统中也可以表示为<br>$$x(t)=x(t-T)+\frac{T}{2}(u(t-T)+u(t)) $$<br>进行拉氏变换<br>$$X(s)=X(s)e^{-sT}+\frac{T}{2}(U(s)e^{-sT}+U(s)) $$<br>我们得到<br>$$\frac{X(s)}{U(s)}=\frac{1}{s}=\frac{1+e^{-sT}}{1-e^{-sT}}\cdot \frac{T}{2} $$<br>$$s= \frac{2}{T} \cdot \frac{1+e^{-sT}}{1-e^{-sT}} $$<br>最带入到系统的传递函数中去</p>
<h3 id="拿来主义">拿来主义</h3><p>最后我们重新写出Z变换后的传递函数<br>$$G_{c_{pid TP}}(z)=\frac{d_0+d_1\cdot z^{-1}+d_2\cdot z^{-2}}{1-c1\cdot z^{-1}-c2\cdot z^{-2}}$$<br>其中各个参数为：<br>$$\begin{align}<br>&amp; d_{0}=K_{p}\frac{4T_{n}\left ( T_{v} + T_{TP} \right )+2T\left ( T_{n}+T_{TP} \right )+T^{2}}{2T_{n}\left ( 2T_{TP}+T \right )}  \label{eq:rel1} \\<br>&amp; d_{1}=-2K_{p}\frac{4T_{n}\left ( T_{v} + T_{TP} \right )-T^{2}}{2T_{n}\left ( 2T_{TP}+T \right )}  \label{eq:rel2} \\<br>&amp; d_{2}=K_{p}\frac{4T_{n}\left ( T_{v} + T_{TP} \right )-2T\left ( T_{n}+T_{TP} \right )+T^{2}}{2T_{n}\left ( 2T_{TP}+T \right )}  \label{eq:rel3} \\<br>&amp; c_{1}=\frac{4T_{TP}}{2T_{TP}+T}  \label{eq:rel4} \\<br>&amp; c_{1}=-\frac{2T_{TP}-T}{2T_{TP}+T}  \label{eq:rel5} \\<br>\end{align}$$</p>
<h3 id="后面的话">后面的话</h3><p>最近事情真的太多了。需要让自己平静下来，争取每个月都能分享一些东西。</p>
]]></content>
    <summary type="html">
    <![CDATA[<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    ]]>
    </summary>
    
      <category term="控制" scheme="http://yoursite.com/tags/%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[QT工程添加PCL库]]></title>
    <link href="http://yoursite.com/2016/05/03/qtpclv/"/>
    <id>http://yoursite.com/2016/05/03/qtpclv/</id>
    <published>2016-05-03T10:04:39.000Z</published>
    <updated>2016-05-03T10:57:45.058Z</updated>
    <content type="html"><![CDATA[<p>&emsp;&emsp;在最近的项目中，需要可视化点云。PCL自然是第一选择。在qt中使用PCL可以参照pcl tutorial建立CMake工程。还有另外一种选择是在qt工程中添加pcl库，依然保留qmake-&gt;make编译过程。因为之前的项目是使用qt工程建立的。我希望保留使用第二种方法。但期间困惑了几个小时才解决。<br>&emsp;&emsp;故，记录一下过程：<br>&emsp;&emsp;我的环境是 Ubuntu14.04 安装PCL：</p>
<p><pre><code>sudo add-apt-repository ppa:v-launchpad-jochen-sprickerhof-de/pcl<br>sudo apt-get update<br>sudo apt-get install libpcl-all<br></code></pre>&emsp;&emsp;在Ubuntu下面安装的时候依赖库也都直接安装好了。在Windows下面开发的时候可以去下载all-in-one的安装包<br>&emsp;&emsp;但是因为pcl是依赖于boost eigen flann VTK QT QHull OpenNi 所以需要依次添加。下面给出*.pro的相关内容：</p>
<p><pre><code>INCLUDEPATH +=  “/usr/include/pcl-1.7/“    \<br>                “/usr/include/pcl-1.7/pcl” \<br>                “/usr/include/flann/“      \<br>                “/usr/include/eigen3/“     \<br>                “/usr/include/vtk-5.8”     \<br>                “/usr/include/boost”       \<br></code></pre></p>
<p><pre><code>LIBS += -lpcl_common            \<br>        -lpcl_features          \<br>        -lpcl_filters           \<br>        -lpcl_io                \<br>        -lpcl_io_ply            \<br>        -lpcl_kdtree            \<br>        -lpcl_keypoints         \<br>        -lpcl_octree            \<br>        -lpcl_outofcore         \<br>        -lpcl_features          \<br>        -lpcl_segmentation      \<br>        -lpcl_people            \<br>        -lpcl_recognition       \<br>        -lpcl_registration      \<br>        -lpcl_sample_consensus  \<br>        -lpcl_search            \<br>        -lpcl_surface           \<br>        -lpcl_tracking          \<br>        -lpcl_visualization     \<br>        -lflann                 \<br>        -lqhull                 \<br>        -lboost_system          \<br>        -lQVTK                  \<br>        -lvtkCommon             \<br>        -lvtkFiltering          \<br>        -lvtkRendering          \<br></code></pre>&emsp;&emsp;综上，主要有两点要注意。其一，*.pro文件需要添加所有的依赖库，否则链接的时候会报错。其二，PCL QVTK5.8只对QT4支持，所以需要用QT4的库(查看方法 qmake -v)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;&emsp;在最近的项目中，需要可视化点云。PCL自然是第一选择。在qt中使用PCL可以参照pcl tutorial建立CMake工程。还有另外一种选择是在qt工程中添加pcl库，依然保留qmake-&gt;make编译过程。因为之前的项目是使用qt工程建立的。]]>
    </summary>
    
      <category term="PCL" scheme="http://yoursite.com/tags/PCL/"/>
    
      <category term="QT" scheme="http://yoursite.com/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学习方向]]></title>
    <link href="http://yoursite.com/2016/03/22/study/"/>
    <id>http://yoursite.com/2016/03/22/study/</id>
    <published>2016-03-21T23:09:26.000Z</published>
    <updated>2016-08-19T20:23:54.385Z</updated>
    <content type="html"><![CDATA[<p>&emsp;&emsp;开始硕士学习半年有余，开心与浑噩并存。<br>&emsp;&emsp;一周前去玩，我在图宾根玩的时候，有当地的工程师人关心我毕业以后希望从事的行业。我想了好久，最后也没有很好的回答上，进入了下一个话题。<br>&emsp;&emsp;小时候总是想着一定要成为一个很厉害的人。各个方面都能做的最好。越长大，越意识到现代社会的职业分工是很细化的，在各个领域都有很深入的认识是不现实的事情。选一个适合自己的方向并且长期的努力下去才是最重要的事情。<br>&emsp;&emsp;回想起本科和两年的工作经历，本科专业虽不是喜欢。但是应付考试的过程确乎大大的拓展了我的知识面。在实践中心的日子，实践能得到了很好的培养。之后很幸运的两段的工作经历都是在深圳成长最快的公司，同时身边不少朋友选择了创业。<br>&emsp;&emsp;于是来德国学习的前半年自己的心理状态很不稳定，航空，机电，创业，三者交织，影响。但是路要一步步走，生活要一天天过。正好下学期能去实验室做课题。希望能在前期吧自己的心理调整到平静的状态。</p>
<p>&emsp;&emsp;长期来说机器人是自己很感兴趣同时也有一定知识储备的方向。短期还是把主要的任务放在三维重建的课题上吧。</p>
<p>&emsp;&emsp;方向有了，心态就好了。<br>&emsp;&emsp;恩，就这样，出发吧！少年！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;&emsp;开始硕士学习半年有余，开心与浑噩并存。<br>&emsp;&emsp;一周前去玩，我在图宾根玩的时候，有当地的工程师人关心我毕业以后希望从事的行业。我想了好久，最后也没有很好的回答上，进入了下一个话题。<br>&emsp;&emsp;小时候总是想着一]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[格雷码]]></title>
    <link href="http://yoursite.com/2015/12/04/greycode/"/>
    <id>http://yoursite.com/2015/12/04/greycode/</id>
    <published>2015-12-04T21:22:16.000Z</published>
    <updated>2015-12-22T16:33:54.744Z</updated>
    <content type="html"><![CDATA[<p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><br>数电中一笔带过的格雷码，在控制课程中又被提及。我们首先介绍一下格雷码的生成过程之后再来谈谈作为编码器的应用。</p>
<p>感谢互联网，大家能方便找到很多生成和反解格雷码的方法。这里介绍的只是其中一种。这也是最终可以直接由硬件层面直接转换的方法。<br>这里要复习一下数电中的异或(XOR)运算,其真值表如下：<br><img src="http://7xnxd9.com1.z0.glb.clouddn.com/greyXOR_TABLE.jpg?imageView2/2/w/640/h/480" alt=""><br>接着我们来说把任意一个数转换为格雷码。<br>第一步 写成二进制形式。 譬如十进制的12其二进制为1100<br>第二部 最高位保留，保留格雷码最高位为1<br>第三部 把每一位和更高位进行异或运算12的运算结果为010<br>第四部 写出格雷码十进制12的格雷码为1010<br>附上手稿：<br><img src="http://7xnxd9.com1.z0.glb.clouddn.com/greybin2gery.jpg?imageView2/2/w/640/h/480" alt=""><br>为了更方便大家理解，有一个<a href="https://github.com/ttoto/grey-code-generator" target="_blank" rel="external">小程序</a>来生成格雷码的码盘。<br>下面滔说说格雷码在绝对编码器里面的应用。在电机控制系统中。编码器可以观测电机的当前位置。单圈绝对编码器能给出但圈内电机的唯一位置。而而格雷码码盘相比于二进制码盘能消除两位间隙中的误差。</p>
<table>
<thead>
<tr>
<th style="text-align:center">&emsp;</th>
<th style="text-align:center">&emsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://7xnxd9.com1.z0.glb.clouddn.com/greybin5.jpg?imageView2/2/w/480/h/360/format/jpg" alt=""></td>
<td style="text-align:center"><img src="http://7xnxd9.com1.z0.glb.clouddn.com/greygrey5.jpg?imageView2/2/w/480/h/360/format/jpg" alt=""></td>
</tr>
</tbody>
</table>
<p>上图左边是二进制码的码盘，右边是格雷码的码盘。我们可以发现格雷码确实做到了相邻两个位置。有且只有一位有变化，能确保在中间过程中不会有超过最小位的误差。</p>
<p>关于格雷码更加详细的介绍可以参见<a href="https://en.wikipedia.org/wiki/Gray_code" target="_blank" rel="external">Wiki</a></p>
<p>岁月如梭，光阴似箭。据我所知或者以我所见，现在有了电磁式的绝对编码器。有格雷码码盘做的光电编码器已经算是大块头的老家伙了。<br>不过。。。格雷码依旧是个很好玩的东西。<br>不是吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><br>数电中一笔带过的格雷码，在控制课程中又被提及。]]>
    </summary>
    
      <category term="控制" scheme="http://yoursite.com/tags/%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件推荐]]></title>
    <link href="http://yoursite.com/2015/11/15/recommand-software/"/>
    <id>http://yoursite.com/2015/11/15/recommand-software/</id>
    <published>2015-11-15T10:49:31.000Z</published>
    <updated>2015-12-22T16:44:39.536Z</updated>
    <content type="html"><![CDATA[<p>&emsp;&emsp;好软件能顶半边天，我想在这里推荐几款自己常用的免费软件。如果有新的好玩的软件我也会更新上来。点击软件名会跳转到相应的地址。</p>
<h3 id="多个任务区，工作生活两不误-Dexpot">多个任务区，工作生活两不误-<a href="http://dexpot.de/" target="_blank" rel="external">Dexpot</a></h3><p>&emsp;&emsp;电脑性能越来越好，桌面越来越挤。同时运行了太多的程序后桌面太乱。</p>
<p><img src="http://7xnxd9.com1.z0.glb.clouddn.com/rstmp1.png?imageView2/2/w/640/h/480/format/jpg" class="img-center"><br>&emsp;&emsp;如果有用过Linux系统的同学是否记得很多linux的发行版支持在多个桌面之间切换。Windows下陆续尝试过几个软件。这款来自德国的免费软件Dexpot是我觉得最好用的。在设置里你可以设置快捷键基本上能获得和Ubuntu下完全一样的体验。</p>
<p><img src="http://7xnxd9.com1.z0.glb.clouddn.com/rstmp4.png?imageView2/2/w/640/h/480" class="img-center"></p>
<h3 id="和浏览器一样的文件管理器-Clover">和浏览器一样的文件管理器-<a href="http://cn.ejie.me/" target="_blank" rel="external">Clover</a></h3><p>&emsp;&emsp;Clover这款软件必须算是业界良心了。让你的文件浏览器和chrom一样支持标签。有很完整的中文说明和支持。</p>
<h3 id="比快更快的PDF阅读器-Sumatrapdf">比快更快的PDF阅读器-<a href="http://www.sumatrapdfreader.org/free-pdf-reader.html" target="_blank" rel="external">Sumatrapdf</a></h3><p>&emsp;&emsp;时至今日，PDF阅读软件的选择太多。但跟多时候我们需要的只是一款简单粗暴的产品。没有广告推荐，界面上没有太多的按钮-保证屏幕上能现实最多的内容，几乎秒开。Sumatrapdf就是最实用的PDF阅读器。当然如果需要注释等功能Foxit还是最好的选择。</p>
<p><img src="http://7xnxd9.com1.z0.glb.clouddn.com/rstmp3.png?imageView2/2/w/640/h/480" class="img-center"></p>
<p>END</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;&emsp;好软件能顶半边天，我想在这里推荐几款自己常用的免费软件。如果有新的好玩的软件我也会更新上来。点击软件名会跳转到相应的地址。</p>
<h3 id="多个任务区，工作生活两不误-Dexpot">多个任务区，工作生活两不误-<a href="http:/]]>
    </summary>
    
      <category term="软件推荐" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[怎样使用基尔霍夫定律解决问题]]></title>
    <link href="http://yoursite.com/2015/11/07/Kirchhoff/"/>
    <id>http://yoursite.com/2015/11/07/Kirchhoff/</id>
    <published>2015-11-07T22:05:02.000Z</published>
    <updated>2015-12-22T16:42:12.437Z</updated>
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p>&emsp;&emsp;</p>
<h3 id="工欲善其事，必先利其器">工欲善其事，必先利其器</h3><p>&emsp;&emsp;从基尔霍夫定理开始说起。上过电路基础课程的同学肯定对<a href="https://en.wikipedia.org/wiki/Kirchhoff%27s_circuit_laws" target="_blank" rel="external">基尔霍夫电流电压定律</a>很了解，我们亦可以可用文字描述成：<br>对于任意节点流入流出电流和为0,<br>$$\sum_{k=0}^{n}I_{k}=0$$<br>对于任意闭合回路电压代数和为0。<br>$$\sum_{k=0}^{n}U_{k}=0$$<br>我们常用下列的题目来考察自己是否能学以致用：<br><img src="http://7xnxd9.com1.z0.glb.clouddn.com/Kirchhofftmp1.png?imageView2/2/w/320/h/240" class="img-center"><br>能很快解出上面的题目的同学不一定对下面的题目很有信心：<br><img src="http://7xnxd9.com1.z0.glb.clouddn.com/Kirchhofftmp2.png?imageView2/2/w/320/h/240" class="img-center"><br>这是因为实际在比较复杂的情况下。要解出上面的</p>
<h3 id="如何准确找出所需的线性无关的方程组">如何准确找出所需的线性无关的方程组</h3><p>&emsp;&emsp;为了更好的说明题目，我们明确两个细节<br>&emsp;&emsp;&emsp;&emsp;1,n=节点个数；<br>&emsp;&emsp;&emsp;&emsp;2,b=电流个数。<br>&emsp;&emsp;在上例中我们可以看出有A~E五个节点,n=5;同时有8个未知电流,b=8。<br>&emsp;&emsp;此外我们引出两个概念”Tree Branch”和”Non-Tree Branch”(主分支与从分支)。其中”Tree Branch”是指连接所有不同节点最少支流。此外的电流算是”Non-Tree Branch”在下图中蓝色标出的是主分支。<br><img src="http://7xnxd9.com1.z0.glb.clouddn.com/Kirchhofftmp4.png?imageView2/2/w/640/h/480" class="img-center"><br>&emsp;&emsp;在选择线性无关的方程组时我们选取(n-1)个节点利用基尔霍夫电流定律建立方程。在选择建立电压定律的方程时我们遵循”Non-Tree Branch”+”Tree Branch”的原则来建立。如上图中的四个闭合回路都包含了Tree。这样我们就能够构建b个线性无关的方程组：<br>$$<br> \begin{equation}<br>\left\{<br>\begin{aligned}<br>I_{1} - I_{2} -I_{4}                                                       &amp;=0\\<br>I_{2} - I_{3} -I_{5}                                                       &amp;=0\\<br>I_{1} - I_{4} -I_{6} -I_{8}                                                &amp;=0\\<br>I_{5} + I_{6} -I_{7}                                                       &amp;=0\\<br>R_1 \cdot I_1 + R_4 \cdot I_4                                              &amp;=U_{1}\\<br>R_2 \cdot I_2 - R_4 \cdot I_4 + R_5 \cdot I_5 - R_6\cdot I_6               &amp;= U_2\\<br>R_2 \cdot I_2 + R_3 \cdot I_3 - R_4 \cdot I_4 - R_6\cdot I_6 - R_7\cdot I_7&amp;=-U_3\\<br>R_6 \cdot I_6 - R_7 \cdot I_7 - R_8 \cdot I_8                              &amp;=0\\<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$<br>&emsp;&emsp;在上面的方程组中 1~4 是利用A\B\C\D四个节点建立的基尔霍夫电流方程， 5~8是按照上述规则建立的基尔霍夫电压方程。通过这样子的建立方式我们能够保证这8个方程是线性无关的。</p>
<h3 id="构建矩阵并求解">构建矩阵并求解</h3><p>$$<br>\begin{pmatrix}<br>1&amp;-1&amp;0&amp;-1&amp;0&amp;0&amp;0&amp;0\\0&amp;1&amp;-1&amp;0&amp;1&amp;0&amp;0&amp;0\\1&amp;0&amp;0&amp;-1&amp;0&amp;-1&amp;0&amp;-1\\0&amp;0&amp;0&amp;0&amp;1&amp;1&amp;-1&amp;0\\R_1&amp;0&amp;0&amp;R_4&amp;0&amp;0&amp;0&amp;0\\0&amp;R_2&amp;R_3&amp;-R_4&amp;R5&amp;-R_6&amp;0&amp;0\\0&amp;R_2&amp;R_3&amp;-R_4&amp;0&amp;-R_6&amp;-R_7&amp;0\\0&amp;0&amp;0&amp;0&amp;0&amp;R_6&amp;R_7&amp;-R_8\end{pmatrix} \cdot \begin{pmatrix}I_1\\I_2\\I_3\\I_4\\I_5\\I_6\\I_7\\I_8\end{pmatrix}=\begin{pmatrix}0\\0\\0\\0\\U_1\\U_{2}\\{-U_3}\\0\end{pmatrix}$$<br>这样在仿真过程中通过对矩阵求逆，就很容易得到各个branch上的电流大小。进而得出结果</p>
<h3 id="说在后面的话">说在后面的话</h3><p>&emsp;&emsp;纸上得来终觉浅，绝知此事要躬行。重新学习了一遍基尔霍夫定律，又有了新的发现。难道这就是螺旋往复的过程？不管你信不信，我是信了。</p>
<p>END</p>
]]></content>
    <summary type="html">
    <![CDATA[<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    ]]>
    </summary>
    
      <category term="基尔霍夫" scheme="http://yoursite.com/tags/%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB/"/>
    
      <category term="电子" scheme="http://yoursite.com/tags/%E7%94%B5%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Biggesee——鸢飞戾天者，望峰息心；经纶世务者，窥谷忘反。]]></title>
    <link href="http://yoursite.com/2015/11/02/02olpelake/"/>
    <id>http://yoursite.com/2015/11/02/02olpelake/</id>
    <published>2015-11-02T10:17:17.000Z</published>
    <updated>2015-11-02T18:31:57.958Z</updated>
    <content type="html"><![CDATA[<p>&emsp;&emsp;来到德国一个月有余。大部分时间都呆在锡根。感谢最近几天的好天气。上个周末有幸和同学一起去了位于Olpe的<a href="https://en.wikipedia.org/wiki/Biggesee" target="_blank" rel="external">Biggesee</a>。没想到距离锡根只有半个小时车程的小镇上有这番美景。</p>
<p><img src="http://7xnxd9.com1.z0.glb.clouddn.com/IMG_20151031_130032.jpg?imageView2/2/w/1024/h/768/format/jpg" alt=""></p>
<p>此间的美景大概只有九寨沟才有罢。回来后迫不及待和好友分享今天的行程。有朋友相机的参数。可是事实上好景与相机无关。若非要问只能给华为4C打个广告了^_^</p>
<p>我想啊，千百年前吴均的《与朱元思书》描述的就是此番景象吧。</p>
<p><center>《与朱元思书》</center></p>
<p><center>吴均</center><br>&emsp;&emsp;风烟俱净，天山共色。从流飘荡，任意东西。自富阳至桐庐一百许里，奇山异水，天下独绝。水皆缥碧，千丈见底。游鱼细石，直视无碍。急湍甚箭，猛浪若奔。<br>&emsp;&emsp;夹岸高山，皆生寒树，负势竞上，互相轩邈，争高直指，千百成峰。泉水激石，泠泠作响；好鸟相鸣，嘤嘤成韵。蝉则千转不穷，猿则百叫无绝。鸢飞戾天者，望峰息心；经纶世务者，窥谷忘反。横柯上蔽，在昼犹昏；疏条交映，有时见日。</p>
<p>更多的图片：</p>
<table>
<thead>
<tr>
<th style="text-align:center">&emsp;</th>
<th style="text-align:center">&emsp;</th>
<th style="text-align:center">&emsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://7xnxd9.com1.z0.glb.clouddn.com/IMG_20151031_130425.jpg?imageView2/2/w/250/h/768/format/jpg" alt=""></td>
<td style="text-align:center"><img src="http://7xnxd9.com1.z0.glb.clouddn.com/IMG_20151031_130947.jpg?imageView2/2/w/250/h/768/format/jpg" alt=""></td>
<td style="text-align:center"><img src="http://7xnxd9.com1.z0.glb.clouddn.com/IMG_20151031_133159.jpg?imageView2/2/w/250/h/768/format/jpg" alt=""></td>
</tr>
</tbody>
</table>
<p><img src="http://7xnxd9.com1.z0.glb.clouddn.com/IMG_20151031_151646.jpg?imageView2/2/w/1024/h/768/format/jpg" alt=""></p>
<p>END</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&emsp;&emsp;来到德国一个月有余。大部分时间都呆在锡根。感谢最近几天的好天气。上个周末有幸和同学一起去了位于Olpe的<a href="https://en.wikipedia.org/wiki/Biggesee" target="_blank" rel="ext]]>
    </summary>
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么飞机上大量使用液压系统]]></title>
    <link href="http://yoursite.com/2015/10/29/fluidpower/"/>
    <id>http://yoursite.com/2015/10/29/fluidpower/</id>
    <published>2015-10-29T21:41:51.000Z</published>
    <updated>2015-10-30T11:29:50.637Z</updated>
    <content type="html"><![CDATA[<p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><br>LZ在国内上学的时候学的是航空工程，其中一个课程是介绍航空液压系统的。教授说液压系统在飞机中是非常重要的。但是学的是囫囵吞枣，并没有留下很深的映像。毕业后，身边从事机务工作的同学和我交谈中提到飞机的液压系统很复杂。但是在浮躁的lz看来液压系统是六七十年代的技术迟早要被电机所替代。后来LZ到了欧洲上学，又上了液压的课程。醍醐灌顶。明白了为什么飞机上大量使用液压系统。</p>
<p>下表是各种传动系统的粗略对比：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center"><strong>mechanical</strong></th>
<th style="text-align:center"><strong>hydraulic</strong></th>
<th style="text-align:center"><strong>pneumatic</strong></th>
<th style="text-align:center"><strong>electric</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>force transmitted by</strong></td>
<td style="text-align:center">rods,gears,belts,cables</td>
<td style="text-align:center">column of liquid</td>
<td style="text-align:center">column of gas</td>
<td style="text-align:center">electrons in wires</td>
</tr>
<tr>
<td><strong>power density</strong></td>
<td style="text-align:center">++</td>
<td style="text-align:center">+</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td><strong>overall efficiency</strong></td>
<td style="text-align:center">++</td>
<td style="text-align:center">+</td>
<td style="text-align:center">-</td>
<td style="text-align:center">+</td>
</tr>
<tr>
<td><strong>distances over which energy  can be transferred</strong></td>
<td style="text-align:center">short</td>
<td style="text-align:center">medium</td>
<td style="text-align:center">medium</td>
<td style="text-align:center">very long</td>
</tr>
<tr>
<td><strong>safety</strong></td>
<td style="text-align:center">similar</td>
<td style="text-align:center">similar</td>
<td style="text-align:center">similar</td>
<td style="text-align:center">similar</td>
</tr>
<tr>
<td><strong>cost of components</strong></td>
<td style="text-align:center">high</td>
<td style="text-align:center">high</td>
<td style="text-align:center">medium</td>
<td style="text-align:center">low</td>
</tr>
</tbody>
</table>
<p>我们发现液压相比于气动来说在power density上的表现要好得多。要想理解这个这个东西我们需要介绍一下<a href="http://baike.baidu.com/view/976448.htm" target="_blank" rel="external">轴功率-shaft power</a>。轴功率是指转动系统(电动机,液压马达)的功率。<br>电机和液压马达的功率如下:<br>电动机$$P_{e-motor}=B\cdot S\cdot a\cdot h\cdot l\cdot d \cdot \pi \cdot n$$</p>
<p>液压马达$$P_{hy-motor}=\Delta P \cdot l\cdot d \cdot \pi \cdot n$$</p>
<p>其中l,d,π,n都是和体积有关的量,所以同样体积的电机和液压马达两者功率的差异主要体现在前半部分力密度Λ上对于电机和液压马达马达他们的力密度分别是：<br>电动机$$\Lambda _{e-motor}=B\cdot S\cdot a$$</p>
<p>其中a是指电机中单位导线通过的电流,由于存在热耗散和散热原因。对于电机来说Λ的最大值在5*10^5左右<br>液压马达$$\Lambda _{hy-motor}=\Delta P$$</p>
<p>现在的液压系统很容易达到50Mpa，即Λ可以很轻松到达5*10^7<br>综上，Λ的差异能够很轻松达到50倍以上甚至百倍。不难推断同样的体积情况下液压作动筒相比于电机系统能提供50倍的功率。或者说同样场合液压系统只占用1/50的体积。现在民航客机的需求是在机翼上需要在有限的空间内安装扰流板,襟翼,缝翼。所以这些控制面板的作动筒必然是采用液压控制的。</p>
<p>或许有一天常温超导技术走进现实，大程度的减少电机的热功率。这样电机的力密度就能上升几个量级。那时候还真可能电机一统天下呢。</p>
<p>拭目以待吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><br>LZ在国内上学的时候学的是航空工程，其中一个课]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[开篇的话]]></title>
    <link href="http://yoursite.com/2015/10/09/hello-world/"/>
    <id>http://yoursite.com/2015/10/09/hello-world/</id>
    <published>2015-10-09T07:28:00.563Z</published>
    <updated>2015-10-09T07:28:00.563Z</updated>
    <content type="html"><![CDATA[<p>欢迎来到Ttoto的后花园，探索更多的秘密。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>欢迎来到Ttoto的后花园，探索更多的秘密。</p>
]]>
    </summary>
    
  </entry>
  
</feed>
